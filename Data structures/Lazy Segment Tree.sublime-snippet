<snippet>
	<content><![CDATA[
template <class Node, class Lazy, class NCOM, class LCOM, class APPL>
struct LazyTree {
  private:
    int N = 1, log = 0; const int size;
    vector<Node> a; vector<Lazy> b;
    NCOM ncom; LCOM lcom; APPL appl;
    const Node iN; const Lazy iL;

    void combine (const int i) { a[i] = ncom(a[i<<1], a[i<<1|1]); }
    void r_apply (const int i, const Lazy u) {
        a[i] = appl(a[i], u); if(i < N) b[i] = lcom(b[i], u);
    }
    void push (const int i) {
        r_apply(i<<1, b[i]), r_apply(i<<1|1, b[i]); b[i] = iL;
    }
 
  public:
    template <typename... T>
    explicit LazyTree (const int _size, const Node _iN, T... args)
        : LazyTree(vector(_size, _iN), args...) {}
    explicit LazyTree (const vector<Node> initial,
                       const Node& _iN, const Lazy& _iL,
                       const NCOM& _ncom,
                       const LCOM& _lcom,
                       const APPL& _appl)
        : size(initial.size()), iN(_iN), iL(_iL),
          ncom(_ncom), lcom(_lcom), appl(_appl) {
        build(initial);
    }

    void build (const vector<Node>& x) {
        while(N < size) N <<= 1, log++;
        a = vector (N+N, iN), b = vector(N, iL);
        for(int i = 0; i < size; i++) a[i+N] = x[i];
        for(int i = N-1; i >= 1; i--) combine(i);
    }

    void up (int l, int r, const Lazy x) {
        assert(0 <= l and l <= r and r <= size), l += N, r += N; if(l == r) return;
        const int lctz = __builtin_ctz(l), rctz = __builtin_ctz(r);
        for(int j = log; j > lctz; --j) push(l >> j);
        for(int j = log; j > rctz; --j) push((r-1) >> j);
        for(int p = l, q = r; p < q; p >>= 1, q >>= 1){
            if(p&1) r_apply(p++, x); if(q&1) r_apply(--q, x);
        }
        for (int i = lctz + 1; i <= log; ++i) combine(l >> i);
        for (int i = rctz + 1; i <= log; ++i) combine((r - 1) >> i);
    }

    Node qu (int l, int r) {
        assert(0 <= l and l <= r and r <= size), l += N, r += N; 
        if(l == r) return iN; if(r-l == size) return a[1];
        const int lctz = __builtin_ctz(l), rctz = __builtin_ctz(r);
        for(int j = log; j > lctz; --j) push(l >> j);
        for(int j = log; j > rctz; --j) push((r-1) >> j);
        Node zl = iN, zr = iN; for(; l < r; l >>= 1, r >>= 1){
            if(l&1) zl = ncom(zl, a[l++]); if(r&1) zr = ncom(a[--r], zr);
        } return ncom(zl, zr);
    }

    // First j in [l, size] such that f(com[l, j)) is FALSE
    int max_right(int l, const function<bool(Node)> f){
        assert(l > -1 and l <= size and f(iN)); 
        if(l == size) return l; Node prev = iN, t = iN; l += N;
            for (int i = log; i >= 1; i--) push(l >> i);
        do{ while(l % 2 == 0) l >>= 1; if(!f(ncom(prev, a[l]))){
                while(l < N and (push(l), 1)) 
                    if(f(t = ncom(prev, a[l<<=1]))) prev = t, l++;
                return l - N;
            }   prev = ncom(prev, a[l++]);
          } while((l & -l) != l); return size;
    }

    // First j in [0, r] such that f(com[j, r)) is TRUE
    int min_left(int r, const function<bool(Node)> f){
        assert(r > -1 and r <= size and f(iN));
        if(r == 0) return r; Node last = iN, t = iN; r += N;
            for (int i = log; i >= 1; i--) push((r - 1) >> i);
        do{ r--; while(r > 1 and r % 2) r >>= 1; if(!f(ncom(a[r], last))){
                while(r < N and (push(r), 1)) 
                    if(f(t = ncom(a[r = r+r+1], last))) last = t, r--;
                return r + 1 - N;
            }   last = ncom(a[r], last);
          } while((r & -r) != r); return 0;
    }
};
]]></content>    
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>ilazytree</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
